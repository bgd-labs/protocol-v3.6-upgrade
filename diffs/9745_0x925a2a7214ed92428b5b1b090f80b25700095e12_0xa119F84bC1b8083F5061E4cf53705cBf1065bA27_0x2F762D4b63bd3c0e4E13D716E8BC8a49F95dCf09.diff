Index: settings
===================================================================
--- settings
+++ settings
@@ -1,15 +1,21 @@
 {
   "remappings": [
-    "solidity-utils/=lib/solidity-utils/src/",
+    "aave-address-book/=lib/aave-helpers/lib/aave-address-book/src/",
+    "aave-helpers/=lib/aave-helpers/",
+    "aave-v3-origin-tests/=lib/aave-v3-origin/tests/",
+    "aave-v3-origin/=lib/aave-v3-origin/src/",
+    "erc4626-tests/=lib/aave-helpers/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/",
     "forge-std/=lib/forge-std/src/",
-    "ds-test/=lib/forge-std/lib/ds-test/src/",
-    "openzeppelin-contracts-upgradeable/=lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/",
-    "openzeppelin-contracts/=lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/",
-    "@openzeppelin/contracts-upgradeable/=lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/contracts/",
-    "@openzeppelin/contracts/=lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/",
-    "erc4626-tests/=lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/",
-    "halmos-cheatcodes/=lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/halmos-cheatcodes/src/"
+    "openzeppelin-contracts-upgradeable/=lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/",
+    "openzeppelin-contracts/=lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/",
+    "solidity-utils/=lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/lib/solidity-utils/src/",
+    "lib/aave-helpers/:aave-address-book/=lib/aave-helpers/lib/aave-address-book/src/",
+    "lib/aave-helpers/:solidity-utils/=lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/lib/solidity-utils/src/",
+    "@openzeppelin/contracts-upgradeable/=lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/contracts/",
+    "@openzeppelin/contracts/=lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/",
+    "ds-test/=lib/aave-v3-origin/lib/forge-std/lib/ds-test/src/",
+    "halmos-cheatcodes/=lib/aave-v3-origin/lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/halmos-cheatcodes/src/"
   ],
   "optimizer": {
     "enabled": true,
     "runs": 200
@@ -19,52 +25,33 @@
     "bytecodeHash": "none",
     "appendCBOR": true
   },
   "outputSelection": {
-    "src/contracts/instances/PoolInstance.sol": {
+    "lib/aave-v3-origin/src/contracts/instances/PoolInstance.sol": {
       "PoolInstance": [
         "*"
       ]
-    },
-    "*": {
-      "*": [
-        "abi",
-        "evm.bytecode",
-        "evm.deployedBytecode",
-        "evm.methodIdentifiers",
-        "metadata",
-        "devdoc",
-        "userdoc",
-        "storageLayout",
-        "evm.gasEstimates"
-      ],
-      "": [
-        "ast"
-      ]
     }
   },
   "evmVersion": "cancun",
   "viaIR": false,
   "libraries": {
-    "src/contracts/protocol/libraries/logic/BorrowLogic.sol": {
-      "BorrowLogic": "0xFeD9871528E713B5038c4c44BbE7a315f56cAdc6"
+    "lib/aave-v3-origin/src/contracts/protocol/libraries/logic/BorrowLogic.sol": {
+      "BorrowLogic": "0x1Fb8f7C906cddD28B42ae6Eb76abC04A91188635"
     },
-    "src/contracts/protocol/libraries/logic/ConfiguratorLogic.sol": {
-      "ConfiguratorLogic": "0x186f45b6e33fCF531c1542509B199646Eb7fa968"
+    "lib/aave-v3-origin/src/contracts/protocol/libraries/logic/ConfiguratorLogic.sol": {
+      "ConfiguratorLogic": "0x6E2aFD57a161d12f34f416c29619BFeAcAC8AA18"
     },
-    "src/contracts/protocol/libraries/logic/EModeLogic.sol": {
-      "EModeLogic": "0xD1bddC05A3BB5A7907d82A1b4F1E21dBCE69c3d5"
+    "lib/aave-v3-origin/src/contracts/protocol/libraries/logic/FlashLoanLogic.sol": {
+      "FlashLoanLogic": "0xE66AdcF153d0bD67a74e5d23e23F90b4011024EC"
     },
-    "src/contracts/protocol/libraries/logic/FlashLoanLogic.sol": {
-      "FlashLoanLogic": "0x50a4646D4f5Cc0e45051bF4f222D02fA39eC749D"
+    "lib/aave-v3-origin/src/contracts/protocol/libraries/logic/LiquidationLogic.sol": {
+      "LiquidationLogic": "0x8dc095F287dBEBD9e15f75BB3DfBF18389BB8104"
     },
-    "src/contracts/protocol/libraries/logic/LiquidationLogic.sol": {
-      "LiquidationLogic": "0x36Ae486289bB807C3C79A1427b9c3D934294ef43"
+    "lib/aave-v3-origin/src/contracts/protocol/libraries/logic/PoolLogic.sol": {
+      "PoolLogic": "0x25Ed699a052B820d772765E26Ed4dD9f0A26F3E5"
     },
-    "src/contracts/protocol/libraries/logic/PoolLogic.sol": {
-      "PoolLogic": "0xE51B69e5722Bf547866A4d7Bc190c6e81b626806"
-    },
-    "src/contracts/protocol/libraries/logic/SupplyLogic.sol": {
-      "SupplyLogic": "0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168"
+    "lib/aave-v3-origin/src/contracts/protocol/libraries/logic/SupplyLogic.sol": {
+      "SupplyLogic": "0x33654b16A4De97bCE05d7dD06803Bf1066f3123C"
     }
   }
 }
\ No newline at end of file
===================================================================
--- src/contracts/instances/PoolInstance.sol
+++ lib/aave-v3-origin/src/contracts/instances/PoolInstance.sol
@@ -11,9 +11,9 @@
  * @author BGD Labs
  * @notice Instance of the Pool for the Aave protocol
  */
 contract PoolInstance is Pool {
-    uint256 public constant POOL_REVISION = 9;
+    uint256 public constant POOL_REVISION = 10;
 
     constructor(
         IPoolAddressesProvider provider,
         IReserveInterestRateStrategy interestRateStrategy_
===================================================================
--- src/contracts/protocol/pool/Pool.sol
+++ lib/aave-v3-origin/src/contracts/protocol/pool/Pool.sol
@@ -6,9 +6,8 @@
 import {Errors} from "../libraries/helpers/Errors.sol";
 import {ReserveConfiguration} from "../libraries/configuration/ReserveConfiguration.sol";
 import {PoolLogic} from "../libraries/logic/PoolLogic.sol";
 import {ReserveLogic} from "../libraries/logic/ReserveLogic.sol";
-import {EModeLogic} from "../libraries/logic/EModeLogic.sol";
 import {SupplyLogic} from "../libraries/logic/SupplyLogic.sol";
 import {FlashLoanLogic} from "../libraries/logic/FlashLoanLogic.sol";
 import {BorrowLogic} from "../libraries/logic/BorrowLogic.sol";
 import {LiquidationLogic} from "../libraries/logic/LiquidationLogic.sol";
@@ -143,16 +142,18 @@
     ) public virtual override {
         SupplyLogic.executeSupply(
             _reserves,
             _reservesList,
+            _eModeCategories,
             _usersConfig[onBehalfOf],
             DataTypes.ExecuteSupplyParams({
                 user: _msgSender(),
                 asset: asset,
                 interestRateStrategyAddress: RESERVE_INTEREST_RATE_STRATEGY,
                 amount: amount,
                 onBehalfOf: onBehalfOf,
-                referralCode: referralCode
+                referralCode: referralCode,
+                supplierEModeCategory: _usersEModeCategory[onBehalfOf]
             })
         );
     }
 
@@ -180,16 +181,18 @@
         {} catch {}
         SupplyLogic.executeSupply(
             _reserves,
             _reservesList,
+            _eModeCategories,
             _usersConfig[onBehalfOf],
             DataTypes.ExecuteSupplyParams({
                 user: _msgSender(),
                 asset: asset,
                 interestRateStrategyAddress: RESERVE_INTEREST_RATE_STRATEGY,
                 amount: amount,
                 onBehalfOf: onBehalfOf,
-                referralCode: referralCode
+                referralCode: referralCode,
+                supplierEModeCategory: _usersEModeCategory[onBehalfOf]
             })
         );
     }
 
@@ -658,10 +661,9 @@
         address asset,
         address from,
         address to,
         uint256 scaledAmount,
-        uint256 scaledBalanceFromBefore,
-        uint256 scaledBalanceToBefore
+        uint256 scaledBalanceFromBefore
     ) external virtual override {
         require(
             _msgSender() == _reserves[asset].aTokenAddress,
             Errors.CallerNotAToken()
@@ -676,9 +678,8 @@
                 from: from,
                 to: to,
                 scaledAmount: scaledAmount,
                 scaledBalanceFromBefore: scaledBalanceFromBefore,
-                scaledBalanceToBefore: scaledBalanceToBefore,
                 oracle: ADDRESSES_PROVIDER.getPriceOracle(),
                 fromEModeCategory: _usersEModeCategory[from]
             })
         );
@@ -786,8 +787,18 @@
         _eModeCategories[id].borrowableBitmap = borrowableBitmap;
     }
 
     /// @inheritdoc IPool
+    function configureEModeCategoryLtvzeroBitmap(
+        uint8 id,
+        uint128 ltvzeroBitmap
+    ) external virtual override onlyPoolConfigurator {
+        // category 0 is reserved for volatile heterogeneous assets and it's always disabled
+        require(id != 0, Errors.EModeCategoryReserved());
+        _eModeCategories[id].ltvzeroBitmap = ltvzeroBitmap;
+    }
+
+    /// @inheritdoc IPool
     function getEModeCategoryData(
         uint8 id
     )
         external
@@ -837,10 +848,17 @@
         return _eModeCategories[id].borrowableBitmap;
     }
 
     /// @inheritdoc IPool
+    function getEModeCategoryLtvzeroBitmap(
+        uint8 id
+    ) external view returns (uint128) {
+        return _eModeCategories[id].ltvzeroBitmap;
+    }
+
+    /// @inheritdoc IPool
     function setUserEMode(uint8 categoryId) external virtual override {
-        EModeLogic.executeSetUserEMode(
+        SupplyLogic.executeSetUserEMode(
             _reserves,
             _reservesList,
             _eModeCategories,
             _usersEModeCategory,
@@ -903,16 +921,18 @@
     ) external virtual override {
         SupplyLogic.executeSupply(
             _reserves,
             _reservesList,
+            _eModeCategories,
             _usersConfig[onBehalfOf],
             DataTypes.ExecuteSupplyParams({
                 user: _msgSender(),
                 asset: asset,
                 interestRateStrategyAddress: RESERVE_INTEREST_RATE_STRATEGY,
                 amount: amount,
                 onBehalfOf: onBehalfOf,
-                referralCode: referralCode
+                referralCode: referralCode,
+                supplierEModeCategory: _usersEModeCategory[onBehalfOf]
             })
         );
     }
 
@@ -988,9 +1008,9 @@
     function setUserEModeOnBehalfOf(
         uint8 categoryId,
         address onBehalfOf
     ) external override onlyPositionManager(onBehalfOf) {
-        EModeLogic.executeSetUserEMode(
+        SupplyLogic.executeSetUserEMode(
             _reserves,
             _reservesList,
             _eModeCategories,
             _usersEModeCategory,
@@ -1040,13 +1060,8 @@
         return address(BorrowLogic);
     }
 
     /// @inheritdoc IPool
-    function getEModeLogic() external pure returns (address) {
-        return address(EModeLogic);
-    }
-
-    /// @inheritdoc IPool
     function getLiquidationLogic() external pure returns (address) {
         return address(LiquidationLogic);
     }
 
===================================================================
--- src/contracts/protocol/libraries/helpers/Errors.sol
+++ lib/aave-v3-origin/src/contracts/protocol/libraries/helpers/Errors.sol
@@ -87,12 +87,16 @@
     error CallerNotRiskOrPoolOrEmergencyAdmin(); // 'The caller of the function is not a risk, pool or emergency admin'
     error LiquidationGraceSentinelCheckFailed(); // 'Liquidation grace sentinel validation failed'
     error InvalidGracePeriod(); // Grace period above a valid range
     error InvalidFreezeState(); // Reserve is already in the passed freeze state
+    error InvalidLtvzeroState(); // Reserve is already in the passed ltvzero state
     error NotBorrowableInEMode(); // Asset not borrowable in eMode
     error CallerNotUmbrella(); // The caller of the function is not the umbrella contract
     error ReserveNotInDeficit(); // The reserve is not in deficit
     error MustNotLeaveDust(); // Below a certain threshold liquidators need to take the full position
     error UserCannotHaveDebt(); // Thrown when a user tries to interact with a method that requires a position without debt
     error SelfLiquidation(); // Thrown when a user tries to liquidate themselves
     error CallerNotPositionManager(); // Thrown when the caller has not been enabled as a position manager of the on-behalf-of user
+    error InvalidCollateralInEmode(address reserve, uint256 categoryId); /// Thrown when trying to enter an eMode with an invalid collateral asset
+    error InvalidDebtInEmode(address reserve, uint256 categoryId); /// Thrown when trying to enter an eMode with an invalid debt asset
+    error MustBeEmodeCollateral(address reserve, uint256 categoryId); /// Thrown when trying to configure an asset as eMode-ltvzero that is not an eMode collateral
 }
Index: src/contracts/protocol/libraries/logic/EModeLogic.sol
===================================================================
--- src/contracts/protocol/libraries/logic/EModeLogic.sol
+++ src/contracts/protocol/libraries/logic/EModeLogic.sol
@@ -1,58 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-pragma solidity ^0.8.10;
-
-import {IPool} from "../../../interfaces/IPool.sol";
-import {DataTypes} from "../types/DataTypes.sol";
-import {ValidationLogic} from "./ValidationLogic.sol";
-
-/**
- * @title EModeLogic library
- * @author Aave
- * @notice Implements the base logic for all the actions related to the eMode
- */
-library EModeLogic {
-    /**
-     * @notice Updates the user efficiency mode category
-     * @dev Will revert if user is borrowing non-compatible asset or change will drop HF < HEALTH_FACTOR_LIQUIDATION_THRESHOLD
-     * @dev Emits the `UserEModeSet` event
-     * @param reservesData The state of all the reserves
-     * @param reservesList The addresses of all the active reserves
-     * @param eModeCategories The configuration of all the efficiency mode categories
-     * @param usersEModeCategory The state of all users efficiency mode category
-     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets
-     * @param user The selected user
-     * @param oracle The address of the oracle
-     * @param categoryId The selected eMode categoryId
-     */
-    function executeSetUserEMode(
-        mapping(address => DataTypes.ReserveData) storage reservesData,
-        mapping(uint256 => address) storage reservesList,
-        mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,
-        mapping(address => uint8) storage usersEModeCategory,
-        DataTypes.UserConfigurationMap storage userConfig,
-        address user,
-        address oracle,
-        uint8 categoryId
-    ) external {
-        if (usersEModeCategory[user] == categoryId) return;
-
-        ValidationLogic.validateSetUserEMode(
-            eModeCategories,
-            userConfig,
-            categoryId
-        );
-
-        usersEModeCategory[user] = categoryId;
-
-        ValidationLogic.validateHealthFactor(
-            reservesData,
-            reservesList,
-            eModeCategories,
-            userConfig,
-            user,
-            categoryId,
-            oracle
-        );
-        emit IPool.UserEModeSet(user, categoryId);
-    }
-}
===================================================================
--- src/contracts/protocol/libraries/logic/SupplyLogic.sol
+++ lib/aave-v3-origin/src/contracts/protocol/libraries/logic/SupplyLogic.sol
@@ -40,8 +40,9 @@
      */
     function executeSupply(
         mapping(address => DataTypes.ReserveData) storage reservesData,
         mapping(uint256 => address) storage reservesList,
+        mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,
         DataTypes.UserConfigurationMap storage userConfig,
         DataTypes.ExecuteSupplyParams memory params
     ) external {
         DataTypes.ReserveData storage reserve = reservesData[params.asset];
@@ -83,14 +84,15 @@
 
         if (isFirstSupply) {
             if (
                 ValidationLogic.validateAutomaticUseAsCollateral(
-                    params.user,
                     reservesData,
                     reservesList,
+                    eModeCategories,
                     userConfig,
                     reserveCache.reserveConfiguration,
-                    reserveCache.aTokenAddress
+                    params.asset,
+                    params.supplierEModeCategory
                 )
             ) {
                 userConfig.setUsingAsCollateral(
                     reserve.id,
@@ -216,10 +218,8 @@
 
     /**
      * @notice Validates a transfer of aTokens. The sender is subjected to health factor validation to avoid
      * collateralization constraints violation.
-     * @dev Emits the `ReserveUsedAsCollateralEnabled()` event for the `to` account, if the asset is being activated as
-     * collateral.
      * @dev In case the `from` user transfers everything, `ReserveUsedAsCollateralDisabled()` is emitted for `from`.
      * @param reservesData The state of all the reserves
      * @param reservesList The addresses of all the active reserves
      * @param eModeCategories The configuration of all the efficiency mode categories
@@ -265,31 +265,8 @@
                         params.fromEModeCategory
                     );
                 }
             }
-
-            if (params.scaledBalanceToBefore == 0) {
-                DataTypes.UserConfigurationMap storage toConfig = usersConfig[
-                    params.to
-                ];
-                if (
-                    ValidationLogic.validateAutomaticUseAsCollateral(
-                        params.from,
-                        reservesData,
-                        reservesList,
-                        toConfig,
-                        reserve.configuration,
-                        reserve.aTokenAddress
-                    )
-                ) {
-                    toConfig.setUsingAsCollateral(
-                        reserveId,
-                        params.asset,
-                        params.to,
-                        true
-                    );
-                }
-            }
         }
     }
 
     /**
@@ -328,9 +305,9 @@
         if (useAsCollateral == userConfig.isUsingAsCollateral(reserve.id))
             return;
 
         if (useAsCollateral) {
-            // When enabeling a reserve as collateral, we want to ensure the user has at least some collateral
+            // When enabling a reserve as collateral, we want to ensure the user has at least some collateral
             require(
                 IAToken(reserve.aTokenAddress).scaledBalanceOf(user) != 0,
                 Errors.UnderlyingBalanceZero()
             );
@@ -338,10 +315,13 @@
             require(
                 ValidationLogic.validateUseAsCollateral(
                     reservesData,
                     reservesList,
+                    eModeCategories,
                     userConfig,
-                    reserveConfigCached
+                    reserveConfigCached,
+                    asset,
+                    userEModeCategory
                 ),
                 Errors.UserInIsolationModeOrLtvZero()
             );
 
@@ -359,5 +339,52 @@
                 userEModeCategory
             );
         }
     }
+
+    /**
+     * @notice Updates the user efficiency mode category
+     * @dev Will revert if user is borrowing non-compatible asset or change will drop HF < HEALTH_FACTOR_LIQUIDATION_THRESHOLD
+     * @dev Emits the `UserEModeSet` event
+     * @param reservesData The state of all the reserves
+     * @param reservesList The addresses of all the active reserves
+     * @param eModeCategories The configuration of all the efficiency mode categories
+     * @param usersEModeCategory The state of all users efficiency mode category
+     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets
+     * @param user The selected user
+     * @param oracle The address of the oracle
+     * @param categoryId The selected eMode categoryId
+     */
+    function executeSetUserEMode(
+        mapping(address => DataTypes.ReserveData) storage reservesData,
+        mapping(uint256 => address) storage reservesList,
+        mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,
+        mapping(address => uint8) storage usersEModeCategory,
+        DataTypes.UserConfigurationMap storage userConfig,
+        address user,
+        address oracle,
+        uint8 categoryId
+    ) external {
+        if (usersEModeCategory[user] == categoryId) return;
+
+        ValidationLogic.validateSetUserEMode(
+            reservesData,
+            reservesList,
+            eModeCategories,
+            userConfig,
+            categoryId
+        );
+
+        usersEModeCategory[user] = categoryId;
+
+        ValidationLogic.validateHealthFactor(
+            reservesData,
+            reservesList,
+            eModeCategories,
+            userConfig,
+            user,
+            categoryId,
+            oracle
+        );
+        emit IPool.UserEModeSet(user, categoryId);
+    }
 }
===================================================================
--- src/contracts/protocol/libraries/logic/LiquidationLogic.sol
+++ lib/aave-v3-origin/src/contracts/protocol/libraries/logic/LiquidationLogic.sol
@@ -404,16 +404,20 @@
             );
         }
 
         if (params.receiveAToken) {
-            _liquidateATokens(
-                reservesData,
-                reservesList,
-                usersConfig,
-                collateralReserve,
-                params,
-                vars
-            );
+            IAToken(vars.collateralReserveCache.aTokenAddress)
+                .transferOnLiquidation(
+                    params.borrower,
+                    params.liquidator,
+                    vars.actualCollateralToLiquidate,
+                    vars
+                        .actualCollateralToLiquidate
+                        .getATokenTransferScaledAmount(
+                            vars.collateralReserveCache.nextLiquidityIndex
+                        ),
+                    vars.collateralReserveCache.nextLiquidityIndex
+                );
         } else {
             // @note Manually updating the cache in case the debt and collateral are the same asset.
             // This ensures the rates are updated correctly, considering the burning of debt
             // in the `_burnDebtTokens` function.
@@ -515,64 +519,8 @@
         });
     }
 
     /**
-     * @notice Liquidates the user aTokens by transferring them to the liquidator.
-     * @dev   The function also checks the state of the liquidator and activates the aToken as collateral
-     *        as in standard transfers if the isolation mode constraints are respected.
-     * @param reservesData The state of all the reserves
-     * @param reservesList The addresses of all the active reserves
-     * @param usersConfig The users configuration mapping that track the supplied/borrowed assets
-     * @param collateralReserve The data of the collateral reserve
-     * @param params The additional parameters needed to execute the liquidation function
-     * @param vars The executeLiquidationCall() function local vars
-     */
-    function _liquidateATokens(
-        mapping(address => DataTypes.ReserveData) storage reservesData,
-        mapping(uint256 => address) storage reservesList,
-        mapping(address => DataTypes.UserConfigurationMap) storage usersConfig,
-        DataTypes.ReserveData storage collateralReserve,
-        DataTypes.ExecuteLiquidationCallParams memory params,
-        LiquidationCallLocalVars memory vars
-    ) internal {
-        uint256 liquidatorPreviousATokenBalance = IAToken(
-            vars.collateralReserveCache.aTokenAddress
-        ).scaledBalanceOf(params.liquidator);
-        IAToken(vars.collateralReserveCache.aTokenAddress)
-            .transferOnLiquidation(
-                params.borrower,
-                params.liquidator,
-                vars.actualCollateralToLiquidate,
-                vars.actualCollateralToLiquidate.getATokenTransferScaledAmount(
-                    vars.collateralReserveCache.nextLiquidityIndex
-                ),
-                vars.collateralReserveCache.nextLiquidityIndex
-            );
-
-        if (liquidatorPreviousATokenBalance == 0) {
-            DataTypes.UserConfigurationMap
-                storage liquidatorConfig = usersConfig[params.liquidator];
-            if (
-                ValidationLogic.validateAutomaticUseAsCollateral(
-                    params.liquidator,
-                    reservesData,
-                    reservesList,
-                    liquidatorConfig,
-                    vars.collateralReserveCache.reserveConfiguration,
-                    vars.collateralReserveCache.aTokenAddress
-                )
-            ) {
-                liquidatorConfig.setUsingAsCollateral(
-                    collateralReserve.id,
-                    params.collateralAsset,
-                    params.liquidator,
-                    true
-                );
-            }
-        }
-    }
-
-    /**
      * @notice Burns the debt tokens of the user up to the amount being repaid by the liquidator
      * or the entire debt if the user is in a bad debt scenario.
      * @dev The function alters the `debtReserveCache` state in `vars` to update the debt related data.
      * @param debtReserveCache The cached debt reserve parameters
@@ -737,14 +685,15 @@
         mapping(uint256 => address) storage reservesList,
         DataTypes.UserConfigurationMap storage borrowerConfig,
         DataTypes.ExecuteLiquidationCallParams memory params
     ) internal {
-        uint256 cachedBorrowerConfig = borrowerConfig.data;
+        // the cache is muted inside the iteration and should not be used for other operations
+        uint256 unsafe_cachedBorrowerConfig = borrowerConfig.data;
         uint256 i = 0;
         bool isBorrowed = false;
-        while (cachedBorrowerConfig != 0) {
-            (cachedBorrowerConfig, isBorrowed, ) = UserConfiguration
-                .getNextFlags(cachedBorrowerConfig);
+        while (unsafe_cachedBorrowerConfig != 0) {
+            (unsafe_cachedBorrowerConfig, isBorrowed, ) = UserConfiguration
+                .getNextFlags(unsafe_cachedBorrowerConfig);
             if (isBorrowed) {
                 address reserveAddress = reservesList[i];
                 if (reserveAddress != address(0)) {
                     DataTypes.ReserveCache memory reserveCache = reservesData[
===================================================================
--- src/contracts/protocol/libraries/types/DataTypes.sol
+++ lib/aave-v3-origin/src/contracts/protocol/libraries/types/DataTypes.sol
@@ -144,8 +144,9 @@
         uint16 liquidationBonus;
         uint128 collateralBitmap;
         string label;
         uint128 borrowableBitmap;
+        uint128 ltvzeroBitmap; // if true, the asset will be treated as ltv0 and ltv0 rules apply
     }
 
     enum InterestRateMode {
         NONE,
@@ -188,8 +189,9 @@
         address interestRateStrategyAddress;
         uint256 amount;
         address onBehalfOf;
         uint16 referralCode;
+        uint8 supplierEModeCategory;
     }
 
     struct ExecuteBorrowParams {
         address asset;
@@ -239,9 +241,8 @@
         address from;
         address to;
         uint256 scaledAmount;
         uint256 scaledBalanceFromBefore;
-        uint256 scaledBalanceToBefore;
         address oracle;
         uint8 fromEModeCategory;
     }
 
===================================================================
--- src/contracts/interfaces/IPool.sol
+++ lib/aave-v3-origin/src/contracts/interfaces/IPool.sol
@@ -588,17 +588,15 @@
      * @param from The user from which the aTokens are transferred
      * @param to The user receiving the aTokens
      * @param scaledAmount The scaled amount being transferred/withdrawn
      * @param scaledBalanceFromBefore The aToken scaled balance of the `from` user before the transfer
-     * @param scaledBalanceToBefore The aToken scaled balance of the `to` user before the transfer
      */
     function finalizeTransfer(
         address asset,
         address from,
         address to,
         uint256 scaledAmount,
-        uint256 scaledBalanceFromBefore,
-        uint256 scaledBalanceToBefore
+        uint256 scaledBalanceFromBefore
     ) external;
 
     /**
      * @notice Returns the list of the underlying assets of all the initialized reserves
@@ -676,8 +674,18 @@
         uint128 borrowableBitmap
     ) external;
 
     /**
+     * @notice Replaces the current eMode ltvzeroBitmap.
+     * @param id The id of the category
+     * @param ltvzeroBitmap The ltvzeroBitmap of the category
+     */
+    function configureEModeCategoryLtvzeroBitmap(
+        uint8 id,
+        uint128 ltvzeroBitmap
+    ) external;
+
+    /**
      * @notice Returns the data of an eMode category
      * @dev DEPRECATED use independent getters instead
      * @param id The id of the category
      * @return The configuration data of the category
@@ -687,8 +695,10 @@
     ) external view returns (DataTypes.EModeCategoryLegacy memory);
 
     /**
      * @notice Returns the label of an eMode category
+     * @dev This function is deprecated and will be removed in a future version.
+     * @custom:deprecated
      * @param id The id of the category
      * @return The label of the category
      */
     function getEModeCategoryLabel(
@@ -722,8 +732,17 @@
         uint8 id
     ) external view returns (uint128);
 
     /**
+     * @notice Returns the ltvzero of an eMode category
+     * @param id The id of the category
+     * @return The ltvzeroBitmap of the category
+     */
+    function getEModeCategoryLtvzeroBitmap(
+        uint8 id
+    ) external view returns (uint128);
+
+    /**
      * @notice Allows a user to use the protocol in eMode
      * @param categoryId The id of the category
      */
     function setUserEMode(uint8 categoryId) external;
@@ -910,13 +929,8 @@
      */
     function getBorrowLogic() external view returns (address);
 
     /**
-     * @notice Gets the address of the external EModeLogic
-     */
-    function getEModeLogic() external view returns (address);
-
-    /**
      * @notice Gets the address of the external LiquidationLogic
      */
     function getLiquidationLogic() external view returns (address);
 
===================================================================
--- src/contracts/protocol/libraries/logic/ValidationLogic.sol
+++ lib/aave-v3-origin/src/contracts/protocol/libraries/logic/ValidationLogic.sol
@@ -52,14 +52,8 @@
      */
     uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1e18;
 
     /**
-     * @dev Role identifier for the role allowed to supply isolated reserves as collateral
-     */
-    bytes32 public constant ISOLATED_COLLATERAL_SUPPLIER_ROLE =
-        keccak256("ISOLATED_COLLATERAL_SUPPLIER");
-
-    /**
      * @notice Validates a supply action.
      * @param reserveCache The cached data of the reserve
      * @param scaledAmount The scaledAmount to be supplied
      */
@@ -168,9 +162,19 @@
 
         require(vars.isActive, Errors.ReserveInactive());
         require(!vars.isPaused, Errors.ReservePaused());
         require(!vars.isFrozen, Errors.ReserveFrozen());
-        require(vars.borrowingEnabled, Errors.BorrowingNotEnabled());
+        if (params.userEModeCategory != 0) {
+            require(
+                EModeConfiguration.isReserveEnabledOnBitmap(
+                    eModeCategories[params.userEModeCategory].borrowableBitmap,
+                    reservesData[params.asset].id
+                ),
+                Errors.NotBorrowableInEMode()
+            );
+        } else {
+            require(vars.borrowingEnabled, Errors.BorrowingNotEnabled());
+        }
         require(
             IERC20(params.reserveCache.aTokenAddress).totalSupply() >=
                 vars.amount,
             Errors.InvalidAmount()
@@ -214,18 +218,8 @@
                 );
             }
         }
 
-        if (params.userEModeCategory != 0) {
-            require(
-                EModeConfiguration.isReserveEnabledOnBitmap(
-                    eModeCategories[params.userEModeCategory].borrowableBitmap,
-                    reservesData[params.asset].id
-                ),
-                Errors.NotBorrowableInEMode()
-            );
-        }
-
         if (params.userConfig.isBorrowingAny()) {
             (vars.siloedBorrowingEnabled, vars.siloedBorrowingAddress) = params
                 .userConfig
                 .getSiloedBorrowingState(reservesData, reservesList);
@@ -346,9 +340,8 @@
         bool collateralReserveActive;
         bool collateralReservePaused;
         bool principalReserveActive;
         bool principalReservePaused;
-        bool isCollateralEnabled;
     }
 
     /**
      * @notice Validates the liquidation action.
@@ -409,15 +402,11 @@
             params.healthFactor < HEALTH_FACTOR_LIQUIDATION_THRESHOLD,
             Errors.HealthFactorNotBelowThreshold()
         );
 
-        vars.isCollateralEnabled =
-            collateralReserve.configuration.getLiquidationThreshold() != 0 &&
-            borrowerConfig.isUsingAsCollateral(collateralReserve.id);
-
         //if collateral isn't enabled as collateral by user, it cannot be liquidated
         require(
-            vars.isCollateralEnabled,
+            borrowerConfig.isUsingAsCollateral(collateralReserve.id),
             Errors.CollateralCannotBeLiquidated()
         );
         require(
             params.totalDebt != 0,
@@ -549,13 +538,20 @@
             userEModeCategory,
             oracle
         );
 
-        require(
-            !hasZeroLtvCollateral ||
-                reservesData[asset].configuration.getLtv() == 0,
-            Errors.LtvValidationFailed()
-        );
+        // If the user has an ltvzero asset, the selected asset must be the ltv0 asset.
+        // This mechanism ensures that a multi-collateral position needs to withdraw/transfer the ltv0 asset first.
+        if (hasZeroLtvCollateral) {
+            require(
+                getUserReserveLtv(
+                    reservesData[asset],
+                    eModeCategories[userEModeCategory],
+                    userEModeCategory
+                ) == 0,
+                Errors.LtvValidationFailed()
+            );
+        }
     }
 
     /**
      * @notice Validates a transfer action.
@@ -595,13 +591,17 @@
     }
 
     /**
      * @notice Validates the action of setting efficiency mode.
+     * @param reservesData The state of all the reserves
+     * @param reservesList The addresses of all the active reserves
      * @param eModeCategories a mapping storing configurations for all efficiency mode categories
      * @param userConfig the user configuration
-     * @param categoryId The id of the category
+     * @param categoryId The id of the users eMode category
      */
     function validateSetUserEMode(
+        mapping(address => DataTypes.ReserveData) storage reservesData,
+        mapping(uint256 => address) storage reservesList,
         mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,
         DataTypes.UserConfigurationMap memory userConfig,
         uint8 categoryId
     ) internal view {
@@ -618,31 +618,52 @@
         if (userConfig.isEmpty()) {
             return;
         }
 
-        // if user is trying to set another category than default we require that
-        // either the user is not borrowing, or it's borrowing assets of categoryId
-        if (categoryId != 0) {
-            uint256 i = 0;
-            bool isBorrowed = false;
-            uint128 cachedBorrowableBitmap = eModeCategory.borrowableBitmap;
-            uint256 cachedUserConfig = userConfig.data;
-            unchecked {
-                while (cachedUserConfig != 0) {
-                    (cachedUserConfig, isBorrowed, ) = UserConfiguration
-                        .getNextFlags(cachedUserConfig);
+        uint256 i = 0;
+        bool isBorrowed = false;
+        bool isEnabledAsCollateral = false;
+        // the cache is muted inside the iteration and should not be used for other operations
+        uint256 unsafe_cachedUserConfig = userConfig.data;
 
-                    if (isBorrowed) {
-                        require(
-                            EModeConfiguration.isReserveEnabledOnBitmap(
-                                cachedBorrowableBitmap,
+        // ensure that in the target eMode (even if it's eMode 0), the assets can still be borrowed and be used as collateral
+        unchecked {
+            while (unsafe_cachedUserConfig != 0) {
+                (
+                    unsafe_cachedUserConfig,
+                    isBorrowed,
+                    isEnabledAsCollateral
+                ) = UserConfiguration.getNextFlags(unsafe_cachedUserConfig);
+
+                // ensure a user can only enter or exit an eMode if all his borrowed assets can be borrowed in the target state
+                if (isBorrowed) {
+                    require(
+                        categoryId != 0
+                            ? EModeConfiguration.isReserveEnabledOnBitmap(
+                                eModeCategory.borrowableBitmap,
                                 i
-                            ),
-                            Errors.NotBorrowableInEMode()
-                        );
-                    }
-                    ++i;
+                            )
+                            : reservesData[reservesList[i]]
+                                .configuration
+                                .getBorrowingEnabled(),
+                        Errors.InvalidDebtInEmode(reservesList[i], categoryId)
+                    );
                 }
+                // the asset must either be collateral inside or outside of eMode
+                if (isEnabledAsCollateral) {
+                    require(
+                        getUserReserveLtv(
+                            reservesData[reservesList[i]],
+                            eModeCategory,
+                            categoryId
+                        ) != 0,
+                        Errors.InvalidCollateralInEmode(
+                            reservesList[i],
+                            categoryId
+                        )
+                    );
+                }
+                ++i;
             }
         }
     }
 
@@ -650,19 +671,32 @@
      * @notice Validates the action of activating the asset as collateral.
      * @dev Only possible if the asset has non-zero LTV and the user is not in isolation mode
      * @param reservesData The state of all the reserves
      * @param reservesList The addresses of all the active reserves
+     * @param eModeCategories a mapping storing configurations for all efficiency mode categories
      * @param userConfig the user configuration
      * @param reserveConfig The reserve configuration
+     * @param asset Address of the reserve to be enabled as collateral
+     * @param categoryId The id of the users eMode category
      * @return True if the asset can be activated as collateral, false otherwise
      */
     function validateUseAsCollateral(
         mapping(address => DataTypes.ReserveData) storage reservesData,
         mapping(uint256 => address) storage reservesList,
+        mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,
         DataTypes.UserConfigurationMap storage userConfig,
-        DataTypes.ReserveConfigurationMap memory reserveConfig
+        DataTypes.ReserveConfigurationMap memory reserveConfig,
+        address asset,
+        uint8 categoryId
     ) internal view returns (bool) {
-        if (reserveConfig.getLtv() == 0) {
+        // asset must have a non zero ltv to be activated as collateral
+        if (
+            getUserReserveLtv(
+                reservesData[asset],
+                eModeCategories[categoryId],
+                categoryId
+            ) == 0
+        ) {
             return false;
         }
         if (!userConfig.isUsingAsCollateralAny()) {
             return true;
@@ -675,42 +709,71 @@
         return (!isolationModeActive && reserveConfig.getDebtCeiling() == 0);
     }
 
     /**
-     * @notice Validates if an asset should be automatically activated as collateral in the following actions: supply,
-     * transfer, and liquidate
-     * @dev This is used to ensure that isolated assets are not enabled as collateral automatically
+     * @notice Validates if an asset should be automatically activated as collateral in the following actions: supply, transfer.
+     * @dev This is used to ensure that isolated assets are not enabled as collateral automatically.
      * @param reservesData The state of all the reserves
      * @param reservesList The addresses of all the active reserves
+     * @param eModeCategories a mapping storing configurations for all efficiency mode categories
      * @param userConfig the user configuration
      * @param reserveConfig The reserve configuration
+     * @param asset Address of the reserve to be enabled as collateral
+     * @param categoryId The id of the users eMode category
      * @return True if the asset can be activated as collateral, false otherwise
      */
     function validateAutomaticUseAsCollateral(
-        address sender,
         mapping(address => DataTypes.ReserveData) storage reservesData,
         mapping(uint256 => address) storage reservesList,
+        mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,
         DataTypes.UserConfigurationMap storage userConfig,
         DataTypes.ReserveConfigurationMap memory reserveConfig,
-        address aTokenAddress
+        address asset,
+        uint8 categoryId
     ) internal view returns (bool) {
         if (reserveConfig.getDebtCeiling() != 0) {
-            // ensures only the ISOLATED_COLLATERAL_SUPPLIER_ROLE can enable collateral as side-effect of an action
-            IPoolAddressesProvider addressesProvider = IncentivizedERC20(
-                aTokenAddress
-            ).POOL().ADDRESSES_PROVIDER();
-            if (
-                !IAccessControl(addressesProvider.getACLManager()).hasRole(
-                    ISOLATED_COLLATERAL_SUPPLIER_ROLE,
-                    sender
-                )
-            ) return false;
+            return false;
         }
         return
             validateUseAsCollateral(
                 reservesData,
                 reservesList,
+                eModeCategories,
                 userConfig,
-                reserveConfig
+                reserveConfig,
+                asset,
+                categoryId
             );
     }
+
+    /**
+     * @notice Returns the ltv of the user in the particular reserve
+     * @param reserveData The reserve configuration
+     * @param eModeCategoryData The users eMode category configuration
+     * @param categoryId The id of the users eMode category
+     **/
+    function getUserReserveLtv(
+        DataTypes.ReserveData storage reserveData,
+        DataTypes.EModeCategory storage eModeCategoryData,
+        uint8 categoryId
+    ) internal view returns (uint256) {
+        if (
+            categoryId != 0 &&
+            EModeConfiguration.isReserveEnabledOnBitmap(
+                eModeCategoryData.collateralBitmap,
+                reserveData.id
+            )
+        ) {
+            if (
+                EModeConfiguration.isReserveEnabledOnBitmap(
+                    eModeCategoryData.ltvzeroBitmap,
+                    reserveData.id
+                )
+            ) {
+                return 0;
+            } else {
+                return eModeCategoryData.ltv;
+            }
+        }
+        return reserveData.configuration.getLtv();
+    }
 }
===================================================================
--- src/contracts/protocol/libraries/logic/GenericLogic.sol
+++ lib/aave-v3-origin/src/contracts/protocol/libraries/logic/GenericLogic.sol
@@ -12,9 +12,9 @@
 import {TokenMath} from "../helpers/TokenMath.sol";
 import {MathUtils} from "../math/MathUtils.sol";
 import {DataTypes} from "../types/DataTypes.sol";
 import {ReserveLogic} from "./ReserveLogic.sol";
-import {EModeLogic} from "./EModeLogic.sol";
+import {ValidationLogic} from "./ValidationLogic.sol";
 
 /**
  * @title GenericLogic library
  * @author Aave
@@ -31,23 +31,22 @@
     struct CalculateUserAccountDataVars {
         uint256 assetPrice;
         uint256 assetUnit;
         uint256 userBalanceInBaseCurrency;
-        uint256 decimals;
+        uint256 unsafe_cachedUserConfig;
+        DataTypes.ReserveConfigurationMap configurationCache;
         uint256 ltv;
         uint256 liquidationThreshold;
         uint256 i;
         uint256 healthFactor;
         uint256 totalCollateralInBaseCurrency;
         uint256 totalDebtInBaseCurrency;
         uint256 avgLtv;
         uint256 avgLiquidationThreshold;
-        uint256 eModeLtv;
         uint256 eModeLiqThreshold;
         uint128 eModeCollateralBitmap;
         address currentReserveAddress;
         bool hasZeroLtvCollateral;
-        bool isInEModeCategory;
     }
 
     /**
      * @notice Calculates the user data across the reserves.
@@ -80,52 +79,43 @@
 
         CalculateUserAccountDataVars memory vars;
 
         if (params.userEModeCategory != 0) {
-            vars.eModeLtv = eModeCategories[params.userEModeCategory].ltv;
             vars.eModeLiqThreshold = eModeCategories[params.userEModeCategory]
                 .liquidationThreshold;
             vars.eModeCollateralBitmap = eModeCategories[
                 params.userEModeCategory
             ].collateralBitmap;
         }
 
-        uint256 userConfigCache = params.userConfig.data;
+        vars.unsafe_cachedUserConfig = params.userConfig.data;
         bool isBorrowed = false;
         bool isEnabledAsCollateral = false;
 
-        while (userConfigCache != 0) {
+        while (vars.unsafe_cachedUserConfig != 0) {
             (
-                userConfigCache,
+                vars.unsafe_cachedUserConfig,
                 isBorrowed,
                 isEnabledAsCollateral
-            ) = UserConfiguration.getNextFlags(userConfigCache);
+            ) = UserConfiguration.getNextFlags(vars.unsafe_cachedUserConfig);
             if (isEnabledAsCollateral || isBorrowed) {
                 vars.currentReserveAddress = reservesList[vars.i];
 
                 if (vars.currentReserveAddress != address(0)) {
                     DataTypes.ReserveData storage currentReserve = reservesData[
                         vars.currentReserveAddress
                     ];
+                    vars.configurationCache = currentReserve.configuration;
 
-                    (
-                        vars.ltv,
-                        vars.liquidationThreshold,
-                        ,
-                        vars.decimals,
-
-                    ) = currentReserve.configuration.getParams();
-
                     unchecked {
-                        vars.assetUnit = 10 ** vars.decimals;
+                        vars.assetUnit =
+                            10 ** vars.configurationCache.getDecimals();
                     }
 
                     vars.assetPrice = IPriceOracleGetter(params.oracle)
                         .getAssetPrice(vars.currentReserveAddress);
 
-                    if (
-                        vars.liquidationThreshold != 0 && isEnabledAsCollateral
-                    ) {
+                    if (isEnabledAsCollateral) {
                         vars
                             .userBalanceInBaseCurrency = _getUserBalanceInBaseCurrency(
                             params.user,
                             currentReserve,
@@ -135,34 +125,38 @@
 
                         vars.totalCollateralInBaseCurrency += vars
                             .userBalanceInBaseCurrency;
 
-                        vars.isInEModeCategory =
+                        vars.ltv = ValidationLogic.getUserReserveLtv(
+                            currentReserve,
+                            eModeCategories[params.userEModeCategory],
+                            params.userEModeCategory
+                        );
+                        if (vars.ltv == 0) {
+                            vars.hasZeroLtvCollateral = true;
+                        } else {
+                            vars.avgLtv +=
+                                vars.userBalanceInBaseCurrency *
+                                vars.ltv;
+                        }
+
+                        if (
                             params.userEModeCategory != 0 &&
                             EModeConfiguration.isReserveEnabledOnBitmap(
                                 vars.eModeCollateralBitmap,
                                 vars.i
-                            );
-
-                        if (vars.ltv != 0) {
-                            vars.avgLtv +=
-                                vars.userBalanceInBaseCurrency *
-                                (
-                                    vars.isInEModeCategory
-                                        ? vars.eModeLtv
-                                        : vars.ltv
-                                );
+                            )
+                        ) {
+                            vars.liquidationThreshold = vars.eModeLiqThreshold;
                         } else {
-                            vars.hasZeroLtvCollateral = true;
+                            vars.liquidationThreshold = vars
+                                .configurationCache
+                                .getLiquidationThreshold();
                         }
 
                         vars.avgLiquidationThreshold +=
                             vars.userBalanceInBaseCurrency *
-                            (
-                                vars.isInEModeCategory
-                                    ? vars.eModeLiqThreshold
-                                    : vars.liquidationThreshold
-                            );
+                            vars.liquidationThreshold;
                     }
 
                     if (isBorrowed) {
                         vars
===================================================================
--- src/contracts/protocol/libraries/configuration/UserConfiguration.sol
+++ lib/aave-v3-origin/src/contracts/protocol/libraries/configuration/UserConfiguration.sol
@@ -181,11 +181,11 @@
         return self.data & BORROWING_MASK != 0;
     }
 
     /**
-     * @notice Checks if a user has not been using any reserve for borrowing or supply
+     * @notice Checks if a user has not been using any reserve for borrowing, or as collateral
      * @param self The configuration object
-     * @return True if the user has not been borrowing or supplying any reserve, false otherwise
+     * @return True if the user has not been borrowing, or using as collateral any reserve, false otherwise
      */
     function isEmpty(
         DataTypes.UserConfigurationMap memory self
     ) internal pure returns (bool) {
===================================================================
--- src/contracts/protocol/tokenization/base/IncentivizedERC20.sol
+++ lib/aave-v3-origin/src/contracts/protocol/tokenization/base/IncentivizedERC20.sol
@@ -171,9 +171,14 @@
     function approve(
         address spender,
         uint256 amount
     ) external virtual override returns (bool) {
-        _approve(_msgSender(), spender, amount);
+        _approve({
+            owner: _msgSender(),
+            spender: spender,
+            amount: amount,
+            emitEvent: true
+        });
         return true;
     }
 
     /// @inheritdoc IERC20
@@ -182,58 +187,82 @@
         address recipient,
         uint256 amount
     ) external virtual override returns (bool) {
         uint120 castAmount = amount.toUint120();
-        _approve(
-            sender,
-            _msgSender(),
-            _allowances[sender][_msgSender()] - castAmount
-        );
+        _spendAllowance({
+            owner: sender,
+            spender: _msgSender(),
+            amount: castAmount,
+            correctedAmount: castAmount
+        });
         _transfer(sender, recipient, castAmount);
         return true;
     }
 
     /**
+     * @notice Sets the allowance of the caller to spend `owner`'s tokens to 0.
+     * @param owner The address whose tokens are being renounced.
+     */
+    function renounceAllowance(address owner) external virtual {
+        _approve({
+            owner: owner,
+            spender: _msgSender(),
+            amount: 0,
+            emitEvent: true
+        });
+    }
+
+    /**
      * @notice Increases the allowance of spender to spend _msgSender() tokens
+     * @dev This function is deprecated and will be removed in a future version.
+     * @custom:deprecated
      * @param spender The user allowed to spend on behalf of _msgSender()
      * @param addedValue The amount being added to the allowance
      * @return `true`
      */
     function increaseAllowance(
         address spender,
         uint256 addedValue
     ) external virtual returns (bool) {
-        _approve(
-            _msgSender(),
-            spender,
-            _allowances[_msgSender()][spender] + addedValue
-        );
+        _approve({
+            owner: _msgSender(),
+            spender: spender,
+            amount: _allowances[_msgSender()][spender] + addedValue,
+            emitEvent: true
+        });
         return true;
     }
 
     /**
      * @notice Decreases the allowance of spender to spend _msgSender() tokens
+     * @dev This function is deprecated and will be removed in a future version.
+     * @custom:deprecated
      * @param spender The user allowed to spend on behalf of _msgSender()
      * @param subtractedValue The amount being subtracted to the allowance
      * @return `true`
      */
     function decreaseAllowance(
         address spender,
         uint256 subtractedValue
     ) external virtual returns (bool) {
-        _approve(
-            _msgSender(),
-            spender,
-            _allowances[_msgSender()][spender] - subtractedValue
-        );
+        uint256 currentAllowance = _allowances[_msgSender()][spender];
+
+        _approve({
+            owner: _msgSender(),
+            spender: spender,
+            amount: currentAllowance - subtractedValue,
+            emitEvent: true
+        });
         return true;
     }
 
     /**
      * @dev Updates `owner`'s allowance for `spender` based on spent `value`.
      *
      * Revert if not enough allowance is available.
      *
+     * Doesn't emit the Approval event.
+     *
      * @param owner The owner of the tokens
      * @param spender The user allowed to spend on behalf of owner
      * @param amount The minimum amount being consumed from the allowance
      * @param correctedAmount The maximum amount being consumed from the allowance
@@ -252,12 +281,22 @@
                 amount
             );
         }
 
+        if (currentAllowance == type(uint256).max) {
+            return;
+        }
+
         uint256 consumption = currentAllowance >= correctedAmount
             ? correctedAmount
             : currentAllowance;
-        _approve(owner, spender, currentAllowance - consumption);
+
+        _approve({
+            owner: owner,
+            spender: spender,
+            amount: currentAllowance - consumption,
+            emitEvent: false
+        });
     }
 
     /**
      * @notice Transfers tokens between two users and apply incentives if defined.
@@ -296,16 +335,21 @@
      * @notice Approve `spender` to use `amount` of `owner`s balance
      * @param owner The address owning the tokens
      * @param spender The address approved for spending
      * @param amount The amount of tokens to approve spending of
+     * @param emitEvent Whether to emit the Approval event
      */
     function _approve(
         address owner,
         address spender,
-        uint256 amount
+        uint256 amount,
+        bool emitEvent
     ) internal virtual {
         _allowances[owner][spender] = amount;
-        emit Approval(owner, spender, amount);
+
+        if (emitEvent) {
+            emit Approval(owner, spender, amount);
+        }
     }
 
     /**
      * @notice Update the name of the token
