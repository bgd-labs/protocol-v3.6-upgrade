===================================================================
--- src/contracts/protocol/libraries/logic/LiquidationLogic.sol
+++ lib/aave-v3-origin/src/contracts/protocol/libraries/logic/LiquidationLogic.sol
@@ -404,16 +404,20 @@
             );
         }
 
         if (params.receiveAToken) {
-            _liquidateATokens(
-                reservesData,
-                reservesList,
-                usersConfig,
-                collateralReserve,
-                params,
-                vars
-            );
+            IAToken(vars.collateralReserveCache.aTokenAddress)
+                .transferOnLiquidation(
+                    params.borrower,
+                    params.liquidator,
+                    vars.actualCollateralToLiquidate,
+                    vars
+                        .actualCollateralToLiquidate
+                        .getATokenTransferScaledAmount(
+                            vars.collateralReserveCache.nextLiquidityIndex
+                        ),
+                    vars.collateralReserveCache.nextLiquidityIndex
+                );
         } else {
             // @note Manually updating the cache in case the debt and collateral are the same asset.
             // This ensures the rates are updated correctly, considering the burning of debt
             // in the `_burnDebtTokens` function.
@@ -515,64 +519,8 @@
         });
     }
 
     /**
-     * @notice Liquidates the user aTokens by transferring them to the liquidator.
-     * @dev   The function also checks the state of the liquidator and activates the aToken as collateral
-     *        as in standard transfers if the isolation mode constraints are respected.
-     * @param reservesData The state of all the reserves
-     * @param reservesList The addresses of all the active reserves
-     * @param usersConfig The users configuration mapping that track the supplied/borrowed assets
-     * @param collateralReserve The data of the collateral reserve
-     * @param params The additional parameters needed to execute the liquidation function
-     * @param vars The executeLiquidationCall() function local vars
-     */
-    function _liquidateATokens(
-        mapping(address => DataTypes.ReserveData) storage reservesData,
-        mapping(uint256 => address) storage reservesList,
-        mapping(address => DataTypes.UserConfigurationMap) storage usersConfig,
-        DataTypes.ReserveData storage collateralReserve,
-        DataTypes.ExecuteLiquidationCallParams memory params,
-        LiquidationCallLocalVars memory vars
-    ) internal {
-        uint256 liquidatorPreviousATokenBalance = IAToken(
-            vars.collateralReserveCache.aTokenAddress
-        ).scaledBalanceOf(params.liquidator);
-        IAToken(vars.collateralReserveCache.aTokenAddress)
-            .transferOnLiquidation(
-                params.borrower,
-                params.liquidator,
-                vars.actualCollateralToLiquidate,
-                vars.actualCollateralToLiquidate.getATokenTransferScaledAmount(
-                    vars.collateralReserveCache.nextLiquidityIndex
-                ),
-                vars.collateralReserveCache.nextLiquidityIndex
-            );
-
-        if (liquidatorPreviousATokenBalance == 0) {
-            DataTypes.UserConfigurationMap
-                storage liquidatorConfig = usersConfig[params.liquidator];
-            if (
-                ValidationLogic.validateAutomaticUseAsCollateral(
-                    params.liquidator,
-                    reservesData,
-                    reservesList,
-                    liquidatorConfig,
-                    vars.collateralReserveCache.reserveConfiguration,
-                    vars.collateralReserveCache.aTokenAddress
-                )
-            ) {
-                liquidatorConfig.setUsingAsCollateral(
-                    collateralReserve.id,
-                    params.collateralAsset,
-                    params.liquidator,
-                    true
-                );
-            }
-        }
-    }
-
-    /**
      * @notice Burns the debt tokens of the user up to the amount being repaid by the liquidator
      * or the entire debt if the user is in a bad debt scenario.
      * @dev The function alters the `debtReserveCache` state in `vars` to update the debt related data.
      * @param debtReserveCache The cached debt reserve parameters
@@ -737,14 +685,15 @@
         mapping(uint256 => address) storage reservesList,
         DataTypes.UserConfigurationMap storage borrowerConfig,
         DataTypes.ExecuteLiquidationCallParams memory params
     ) internal {
-        uint256 cachedBorrowerConfig = borrowerConfig.data;
+        // the cache is muted inside the iteration and should not be used for other operations
+        uint256 unsafe_cachedBorrowerConfig = borrowerConfig.data;
         uint256 i = 0;
         bool isBorrowed = false;
-        while (cachedBorrowerConfig != 0) {
-            (cachedBorrowerConfig, isBorrowed, ) = UserConfiguration
-                .getNextFlags(cachedBorrowerConfig);
+        while (unsafe_cachedBorrowerConfig != 0) {
+            (unsafe_cachedBorrowerConfig, isBorrowed, ) = UserConfiguration
+                .getNextFlags(unsafe_cachedBorrowerConfig);
             if (isBorrowed) {
                 address reserveAddress = reservesList[i];
                 if (reserveAddress != address(0)) {
                     DataTypes.ReserveCache memory reserveCache = reservesData[
