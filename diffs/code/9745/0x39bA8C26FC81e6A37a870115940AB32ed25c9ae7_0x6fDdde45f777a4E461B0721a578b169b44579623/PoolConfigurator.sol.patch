===================================================================
--- src/contracts/protocol/pool/PoolConfigurator.sol
+++ lib/aave-v3-origin/src/contracts/protocol/pool/PoolConfigurator.sol
@@ -173,8 +173,12 @@
             newLtv = 0;
 
             emit PendingLtvChanged(asset, ltv);
         } else {
+            if (_pendingLtv[asset] != 0) {
+                delete _pendingLtv[asset];
+                emit PendingLtvChanged(asset, 0);
+            }
             currentConfig.setLtv(ltv);
         }
 
         currentConfig.setLiquidationThreshold(liquidationThreshold);
@@ -220,44 +224,73 @@
     function setReserveFreeze(
         address asset,
         bool freeze
     ) external override onlyRiskOrPoolOrEmergencyAdmins {
-        DataTypes.ReserveConfigurationMap memory currentConfig = _pool
-            .getConfiguration(asset);
+        DataTypes.ReserveDataLegacy memory reserveData = _pool.getReserveData(
+            asset
+        );
+        DataTypes.ReserveConfigurationMap memory currentConfig = reserveData
+            .configuration;
 
         require(
             freeze != currentConfig.getFrozen(),
             Errors.InvalidFreezeState()
         );
 
         currentConfig.setFrozen(freeze);
 
-        uint256 ltvSet;
-        uint256 pendingLtvSet;
-
         if (freeze) {
-            pendingLtvSet = currentConfig.getLtv();
-            _pendingLtv[asset] = pendingLtvSet;
-            currentConfig.setLtv(0);
-        } else {
-            ltvSet = _pendingLtv[asset];
-            currentConfig.setLtv(ltvSet);
-            delete _pendingLtv[asset];
+            _setReserveLtvzero(asset, true, currentConfig);
+            uint128 collateralEnabledBitmap;
+            uint128 ltvzeroBitmap;
+            // The loop will worst case do 2 * 255 SLOADs + 255 SSTOREs, which should be around ~6M gas.
+            // In practice, a single asset will never be enabled as collateral on all eModes, so the expected gas consumption is much lower.
+            // uint256 to not overflow when `j = type(uint8).max + 1`
+            for (uint256 j = 1; j <= type(uint8).max; j++) {
+                collateralEnabledBitmap = _pool
+                    .getEModeCategoryCollateralBitmap(uint8(j));
+                if (
+                    EModeConfiguration.isReserveEnabledOnBitmap(
+                        collateralEnabledBitmap,
+                        reserveData.id
+                    )
+                ) {
+                    ltvzeroBitmap = _pool.getEModeCategoryLtvzeroBitmap(
+                        uint8(j)
+                    );
+                    _setEmodeLtvZero(
+                        ltvzeroBitmap,
+                        asset,
+                        reserveData.id,
+                        uint8(j),
+                        true
+                    );
+                }
+            }
         }
 
-        emit PendingLtvChanged(asset, pendingLtvSet);
-        emit CollateralConfigurationChanged(
-            asset,
-            ltvSet,
-            currentConfig.getLiquidationThreshold(),
-            currentConfig.getLiquidationBonus()
-        );
-
         _pool.setConfiguration(asset, currentConfig);
         emit ReserveFrozen(asset, freeze);
     }
 
     /// @inheritdoc IPoolConfigurator
+    function setReserveLtvzero(
+        address asset,
+        bool ltvZero
+    ) external onlyRiskOrPoolOrEmergencyAdmins {
+        DataTypes.ReserveConfigurationMap memory currentConfig = _pool
+            .getConfiguration(asset);
+        uint256 configCache = currentConfig.data;
+
+        _setReserveLtvzero(asset, ltvZero, currentConfig);
+        require(
+            currentConfig.data != configCache,
+            Errors.InvalidLtvzeroState()
+        );
+        _pool.setConfiguration(asset, currentConfig);
+    }
+
+    /// @inheritdoc IPoolConfigurator
     function setBorrowableInIsolation(
         address asset,
         bool borrowable
     ) external override onlyRiskOrPoolAdmins {
@@ -340,11 +373,9 @@
         DataTypes.ReserveConfigurationMap memory currentConfig = _pool
             .getConfiguration(asset);
 
         uint256 oldDebtCeiling = currentConfig.getDebtCeiling();
-        if (
-            currentConfig.getLiquidationThreshold() != 0 && oldDebtCeiling == 0
-        ) {
+        if (_checkAssetIsCollateral(asset) && oldDebtCeiling == 0) {
             _checkNoSuppliers(asset);
         }
         currentConfig.setDebtCeiling(newDebtCeiling);
         _pool.setConfiguration(asset, currentConfig);
@@ -482,8 +513,41 @@
         require(
             reserveData.id != 0 || _pool.getReservesList()[0] == asset,
             Errors.AssetNotListed()
         );
+        // Disabling an asset from an eMode is always a difficult situation and
+        // must be performed taking into account the current exposure.
+        // The following checks only ensure the protocol stays in a valid state, it does not account for effects triggered by the change.
+        if (!allowed) {
+            DataTypes.ReserveConfigurationMap memory currentConfig = _pool
+                .getConfiguration(asset);
+            if (currentConfig.getLiquidationThreshold() == 0)
+                _checkNoSuppliers(asset);
+
+            uint128 ltvzeroBitmap = _pool.getEModeCategoryLtvzeroBitmap(
+                categoryId
+            );
+            // if removing an asset from an eMode it must also be removed from the ltvzero bitmap
+            if (
+                EModeConfiguration.isReserveEnabledOnBitmap(
+                    ltvzeroBitmap,
+                    reserveData.id
+                )
+            ) {
+                _setEmodeLtvZero(
+                    ltvzeroBitmap,
+                    asset,
+                    reserveData.id,
+                    categoryId,
+                    false
+                );
+            }
+        } else {
+            require(
+                !reserveData.configuration.getFrozen(),
+                Errors.ReserveFrozen()
+            );
+        }
         collateralBitmap = EModeConfiguration.setReserveBitmapBit(
             collateralBitmap,
             reserveData.id,
             allowed
@@ -523,8 +587,48 @@
         emit AssetBorrowableInEModeChanged(asset, categoryId, borrowable);
     }
 
     /// @inheritdoc IPoolConfigurator
+    function setAssetLtvzeroInEMode(
+        address asset,
+        uint8 categoryId,
+        bool ltvzero
+    ) external onlyRiskOrPoolOrEmergencyAdmins {
+        uint128 ltvzeroBitmap = _pool.getEModeCategoryLtvzeroBitmap(categoryId);
+        DataTypes.ReserveDataLegacy memory reserveData = _pool.getReserveData(
+            asset
+        );
+        require(
+            reserveData.id != 0 || _pool.getReservesList()[0] == asset,
+            Errors.AssetNotListed()
+        );
+        uint128 collateralBitmap = _pool.getEModeCategoryCollateralBitmap(
+            categoryId
+        );
+        require(
+            EModeConfiguration.isReserveEnabledOnBitmap(
+                collateralBitmap,
+                reserveData.id
+            ),
+            Errors.MustBeEmodeCollateral(asset, categoryId)
+        );
+        // ltvzero can only be removed on non frozen reserves
+        if (!ltvzero) {
+            require(
+                !reserveData.configuration.getFrozen(),
+                Errors.ReserveFrozen()
+            );
+        }
+        _setEmodeLtvZero(
+            ltvzeroBitmap,
+            asset,
+            reserveData.id,
+            categoryId,
+            ltvzero
+        );
+    }
+
+    /// @inheritdoc IPoolConfigurator
     function setReserveInterestRateData(
         address asset,
         bytes calldata rateData
     ) external onlyRiskOrPoolAdmins {
@@ -593,8 +697,85 @@
     function getConfiguratorLogic() external pure returns (address) {
         return address(ConfiguratorLogic);
     }
 
+    function _setReserveLtvzero(
+        address asset,
+        bool ltvZero,
+        DataTypes.ReserveConfigurationMap memory currentConfig
+    ) internal {
+        uint256 newLtv;
+        uint256 newPendingLtv;
+        if (ltvZero) {
+            if (currentConfig.getLtv() == 0) return;
+            newPendingLtv = currentConfig.getLtv();
+            _pendingLtv[asset] = newPendingLtv;
+            currentConfig.setLtv(0);
+        } else {
+            // ltvzero can only be removed on non frozen reserves
+            require(!currentConfig.getFrozen(), Errors.ReserveFrozen());
+            newLtv = _pendingLtv[asset];
+            if (newLtv == 0 || currentConfig.getLtv() != 0) return;
+            currentConfig.setLtv(newLtv);
+            delete _pendingLtv[asset];
+        }
+        emit PendingLtvChanged(asset, newPendingLtv);
+        emit CollateralConfigurationChanged(
+            asset,
+            newLtv,
+            currentConfig.getLiquidationThreshold(),
+            currentConfig.getLiquidationBonus()
+        );
+    }
+
+    function _setEmodeLtvZero(
+        uint128 ltvzeroBitmap,
+        address reserve,
+        uint16 reserveId,
+        uint8 eModeCategoryId,
+        bool ltvzero
+    ) internal {
+        ltvzeroBitmap = EModeConfiguration.setReserveBitmapBit(
+            ltvzeroBitmap,
+            reserveId,
+            ltvzero
+        );
+        _pool.configureEModeCategoryLtvzeroBitmap(
+            eModeCategoryId,
+            ltvzeroBitmap
+        );
+        emit AssetLtvzeroInEModeChanged(reserve, eModeCategoryId, ltvzero);
+    }
+
+    function _checkAssetIsCollateral(
+        address asset
+    ) internal view returns (bool) {
+        DataTypes.ReserveDataLegacy memory reserveData = _pool.getReserveData(
+            asset
+        );
+        DataTypes.ReserveConfigurationMap memory currentConfig = reserveData
+            .configuration;
+
+        if (currentConfig.getLiquidationThreshold() != 0) return true;
+        uint128 collateralEnabledBitmap;
+        // The loop will worst case do 255 SLOADs, which should be around ~550k gas.
+        // uint256 to not overflow when `j = type(uint8).max + 1`
+        for (uint256 j = 1; j <= type(uint8).max; j++) {
+            collateralEnabledBitmap = _pool.getEModeCategoryCollateralBitmap(
+                uint8(j)
+            );
+            if (
+                EModeConfiguration.isReserveEnabledOnBitmap(
+                    collateralEnabledBitmap,
+                    reserveData.id
+                )
+            ) {
+                return true;
+            }
+        }
+        return false;
+    }
+
     function _checkNoSuppliers(address asset) internal view {
         DataTypes.ReserveDataLegacy memory reserveData = _pool.getReserveData(
             asset
         );
